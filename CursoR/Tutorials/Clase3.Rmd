---
title: "Clase 3:Introducción a R"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    includes:
      in_header: google-analytics.html
runtime: shiny_prerendered
theme: united
description: >
  Clase 3 de introducción a R.Introducción al diseño de funciones.
---

```{r setup, include=FALSE}

library(stringr) 
library(purrr)
library(learnr)
library(knitr)
library(lubridate)
knitr::opts_chunk$set(echo = TRUE,warning = FALSE, message = FALSE,fig.width =10 , fig.height = 8)
tutorial_options(exercise.timelimit = 120)
knit_hooks$set(optipng = hook_optipng)
knit_hooks$set(pngquant = hook_pngquant)


df <- data.frame(Alajuela = round(runif(10,0,20000)),
                 Saprissa = round(runif(10,0,20000)),
                 Cartago = round(runif(10,0,5000)),
                 Heredia = round(runif(10,0,10000)),
                 PerezZeledon = round(runif(10,0,8000)),
                 SanCarlos = round(runif(10,0,6000)),
                 Grecia = round(runif(10,0,5000)),
                 UCR = round(runif(10,0,500)),
                 Carmelita= round(runif(10,0,500)),
                 Guadalupe = round(runif(10,0,1500)),
                 Limon = round(runif(10,0,4500))
                 )


montoPromedio <- function(vector,precio){ # dentro de "function" se incluyen los argumentos de la función
  
  # Cuerpo de la función
  
  calculo<- sum(vector)*precio/length(vector)
  calculop <- paste0("El valor promedio es de ", calculo)
  
  # En return se incluye el resultado deseado que la función debe guardar
  # Cuando se tienen varios resultados se pueden guardar en una lista
  
  return(calculop)
}

```

![](https://www.tec.ac.cr/sites/default/files/media/branding/logo-tec.png){width="289"}

## Funciones

Una de las maneras de incrementar nuestro valor como analistas de datos, es entender la potencia y flexibilidad que ofrece crear funciones personalizadas.

Las funciones permiten al analista automatizar tareas comunes en una forma más inteligente y conveniente que el copiar y pegar, de tal manera que se cree un proceso genérico que sea aplicable a diversas situaciones en múltiples contextos.

**Cuando se debe escribir una función?**

Se debe considerar escribir una función cuando el analista se encuentra a si mismo copiando y pegando el mismo codigo más de al menos 3 veces.

Por ejemplo:

```{r Functions1,exercise=TRUE}

#Data frame ficticio de asistencia de aficionados equipos

df <- data.frame(Alajuela = round(runif(10,0,20000)),
                 Saprissa = round(runif(10,0,20000)),
                 Cartago = round(runif(10,0,5000)),
                 Heredia = round(runif(10,0,10000)),
                 PerezZeledon = round(runif(10,0,8000)),
                 SanCarlos = round(runif(10,0,6000)),
                 Grecia = round(runif(10,0,5000)),
                 UCR = round(runif(10,0,500)),
                 Carmelita= round(runif(10,0,500)),
                 Guadalupe = round(runif(10,0,1500)),
                 Limon = round(runif(10,0,4500))
                 )

df

#Ahora, queremos obtener la venta promedio de cada equipo,basado en un monto  de costo de entrada:

precio<-5000
sum(df$Alajuela)*precio/nrow(df)


```

Una manera más elegante,eficiente y reproducible de lograr este tipo de tareas es mediante la creación de funciones.

El anterior ejemplo se puede escribir mediante la siguiente función:

```{r Functions2,exercise=TRUE}


# Creación de función


montoPromedio <- function(vector,precio){ # dentro de "function" se incluyen los argumentos de la función
  
  # Cuerpo de la función
  
  calculo<- sum(vector)*precio/length(vector)
  calculop <- paste0("El valor promedio es de ", calculo)
  
  # En return se incluye el resultado deseado que la función debe guardar
  # Cuando se tienen varios resultados se pueden guardar en una lista
  
  return(calculop)
}

#Probar la función

MontoAlajuela <- montoPromedio(vector=df$Alajuela,precio=5000)

MontoAlajuela


```

Veamos un ejemplo más:

Una persona desea sacar un préstamo, de $P$ colones a una tasa de interés mensual $i$. El préstamo tiene que ser reembolsado en $n$ cuotas mensuales de tamaño $R$, comenzando dentro de un mes. El problema es calcular $R$. La fórmula $R$ es:

$$ R = P \cdot \left( \frac{i}{1 - (1 + i)^{-n}} \right) $$

Si suponemos que $P=150000$, que la tasa de interés es del 2% y que el número de pagos es 10. EL código en R sería:

```{r functions3,exercise=TRUE}

tasa.interes <- 0.02
n <- 10
principal <- 150000
pago <- principal * tasa.interes/(1 - (1 + tasa.interes)^(-n))
pago

```

Escribiendolo como una función:

```{r functions4,exercise=TRUE}

calcula.cuota <- function(tasa.interes, n, principal) {
    pago <- principal * tasa.interes/(1 - (1 + tasa.interes)^(-n))
    return(pago)
}

calcula.cuota(tasa.interes=0.02, n=10,principal= 150000)

#Otros datos

calcula.cuota(tasa.interes=0.08, n=5,principal= 1000000)

#Sin los nombres de argumentos

calcula.cuota(0.08,5,1000000)


```

### Su turno

Diseñe una función que tenga como input el argumento "nombre" y devuelva como output el texto " Bienvenido \<valor de nombre\> al curso de Introducción a R".

```{r functions4b, exercise=TRUE}

```

```{r functions4b-hint}

#puede utilizar la función paste0()

```

## La sentencia `if`

La clásica sentencia `if` cumple la función de toma de decisiones con respecto a algún flujo de datos.

La estructura de la función es la siguiente:

```{r if,eval=F}

if (test_expression) {
statement
}

```

Si `test_expression` es igual a `TRUE`, el `statement` se ejecuta.Pero si `test_expression` es igual a `FALSE`, nada pasa.Acá,`test_expression` puede ser lógico o numérico, pero solamente el primer elemento es tomado en consideración:

```{r if2,exercise=TRUE}

x <- 5

if(x > 0){
print("Positive number")
}

x <- -5

if(x > 0){
print("Positive number")
}


```

El diagrama de la sentencia `if` es el siguiente:

![Flujograma de la sentencia if](https://cdn.datamentor.io/wp-content/uploads/2017/11/r-if-statement.jpg "Flujograma de la sentencia if")

## Agregando `else`

En la función anterior, observamos como no pasaba nada si la operación no se cumplia.

Agragando el componente `else`, se puede evaluar tanto para el resultado `TRUE` como el `FALSE` .La estructura es la siguiente:

```{r if3,eval=FALSE}

if (test_expression) {
  
statement1
  
} else {
  
statement2
}


```

El diagrama de la sentencia `if` `else` es el siguiente:

[![](https://cdn.datamentor.io/wp-content/uploads/2017/11/r-if-else-statement.jpg "Flujograma de la sentencia if else")](Flujograma%20de%20la%20sentencia%20if%20else)

```{r if4,exercise=TRUE}

x <- -5
if(x > 0){
print("Non-negative number")
} else {
print("Negative number")
}


```

## `if` ... `else` encadenado

En muchas ocasiones, tenemos más de dos alternativas, por lo que podemos utilizar la sentencia de manera encadenada:

```{r if5,eval=FALSE}

if ( test_expression1) {
statement1
} else if ( test_expression2) {
statement2
} else if ( test_expression3) {
statement3
} else {
statement4
}

```

Siguiendo el mismo ejemplo:

```{r if6,exercise=TRUE}

x <- 0
if (x < 0) {
print("Negative number")
} else if (x > 0) {
print("Positive number")
} else
print("Zero")

```

Alternativamente se puede utilizar la función `ifelse`.

```{r if7,exercise=TRUE}

x <-0

ifelse(x<0,"Negative number","Zero or positive number")

```

## Su turno: Laboratorio Grupal

1.  Cree una función que retorne la suma de dos números enteros.

2.  Cree una función que retorne `TRUE` si existe algún entero dentro de un vector.Puede utilizar las funciones `is.numeric()` y `as.numeric()` para resolverlo.

3.  Cree una función que dado un vector numérico imprima el promedio, valores máximo y mínimo de dicho vector.

4.  Cree una función en la que dado un dataframe, devuelva en varios elementos de una lista: a) la estructura del dataframe, b) resumen estadístico, c) top n de observaciones(n debe ser un parámetro de entrada de la función).

5.  Mejore la función `ifelse` utilizada en este tutorial para que en lugar de devolver "*Zero or positive number*" para números mayores o iguales a 0 devuelva por separado un resultado para x=0 o x\>0.Sugerencia: Debe utilizar de nuevo la función `ifelse` para evaluar la instrucción adicional.

6.  Ejecute, evalue y corrija el siguiente codigo:

```{r final, eval=F}

a <- 200
b <- 33

if (b > a) {
  print("b is greater than a")
} else if(a == b) 
  print("a and b are equal")
} else {
  print("a is greater than b")
}
  }

```
